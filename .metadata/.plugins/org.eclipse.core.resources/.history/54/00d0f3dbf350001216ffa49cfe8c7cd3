package com.vectorone;


import android.content.Context;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.widget.TextView;

public class OverlaySurfaceView  extends SurfaceView implements SurfaceHolder.Callback {
 class OverlayThread extends Thread {   
  public static final int STATE_PAUSE = 1;
  public static final int STATE_READY = 2; 
  public static final int STATE_RUNNING = 3; 

       /** The state of the game. One of READY, RUNNING, PAUSE*/
       private int mMode;
 
       /** Indicate whether the surface has been created & is ready to draw */
       private boolean mRun = false;

       /** Handle to the surface manager object we interact with */
       private SurfaceHolder mSurfaceHolder;

       /** The drawable to use as the background of the animation canvas */
       private Bitmap mBackgroundImage;
      
       private Drawable mOverlayImage;
      
       /** What to draw for the player when he is firing */
       private Drawable mFiringImage;
      
       /** Is the engine burning? */
       private boolean mFiring;
      
       /** Used to figure out elapsed time between frames */
       private long mLastTime;
      
       /**
        * Current height of the surface/canvas.
        *
        * @see #setSurfaceSize
        */
       private int mCanvasHeight = 1;

       /**
        * Current width of the surface/canvas.
        *
        * @see #setSurfaceSize
        */
       private int mCanvasWidth = 1;
      
       private Paint mLinePaint;
       private Paint mBlackPaint;

       public OverlayThread(SurfaceHolder surfaceHolder, Context context) {
           // get handles to some important objects
           mSurfaceHolder = surfaceHolder;
           mContext = context;

           Resources res = context.getResources();
           // cache handles to our key sprites & other drawables
           mOverlayImage = res.getDrawable(R.drawable.roterpunkt_th);
         
           // load background image as a Bitmap instead of a Drawable b/c
           // we don't need to transform it and it's faster to draw this way
           mBackgroundImage = BitmapFactory.decodeResource(res,R.drawable.roterpunkt_th);

         
           //Initialize paints for speedometer
           mLinePaint = new Paint();
           mLinePaint.setAntiAlias(true);
           mLinePaint.setARGB(255, 0, 255, 0);
          
           mBlackPaint = new Paint();
           mBlackPaint.setStyle(Paint.Style.FILL);
           mBlackPaint.setColor(Color.BLACK);

           // initial setting
       }

       /**
        * Starts the game, setting parameters for the current difficulty.
        */
       public void doStart() {
           synchronized (mSurfaceHolder) {

               mLastTime = System.currentTimeMillis() + 100;
             
           }
       }
      

       /**
        * Pauses the physics update & animation.
        */
       public void pause() {
           synchronized (mSurfaceHolder) {
               if (mMode == STATE_RUNNING) setState(STATE_PAUSE);
           }
       }

       /**
        * Restores game state from the indicated Bundle. Typically called when
        * the Activity is being restored after having been previously
        * destroyed.
        *
        * @param savedState Bundle containing the game state
        */
       public synchronized void restoreState(Bundle savedState) {
           synchronized (mSurfaceHolder) {
            
              //resetting the variabale from the bundle (see LunarView)
           }
       }

       @Override
       public void run() {
           while (mRun) {
               Canvas c = null;
               try {
                   c = mSurfaceHolder.lockCanvas(null);
                   synchronized (mSurfaceHolder) {
                       updateWorld();
                       doDraw(c);
                   }
               } finally {
                   // do this in a finally so that if an exception is thrown
                   // during the above, we don't leave the Surface in an
                   // inconsistent state
                   if (c != null) {
                       mSurfaceHolder.unlockCanvasAndPost(c);
                   }
               }
           }
       }

       /**
        * Used to signal the thread whether it should be running or not.
        * Passing true allows the thread to run; passing false will shut it
        * down if it's already running. Calling start() after this was most
        * recently called with false will result in an immediate shutdown.
        *
        * @param b true to run, false to shut down
        */
       public void setRunning(boolean b) {
           mRun = b;
       }

       /**
        * Sets the game mode. That is, whether we are running, paused, in the
        * failure state, in the victory state, etc.
        *
        * @see #setState(int, CharSequence)
        * @param mode one of the STATE_* constants
        */
       public void setState(int mode) {
           synchronized (mSurfaceHolder) {
            mMode = mode;
           }
       }

     
     
       /**
        * Draws the ship, fuel/speed bars, and background to the provided
        * Canvas.
        */
       private void doDraw(Canvas canvas) {
      
         //canvas.drawBitmap(mBackgroundImage, 0, 0, null);

          
           //canvas.drawLine((float)1.0, (float)1.0 + mCanvasHeight ,(float)1.0, (float)1.0  + mCanvasHeight, mLinePaint);
     
        //canvas.drawColor(0x2500FF00);
         
          mOverlayImage.setBounds(20, 20, 100, 100);
             mOverlayImage.draw(canvas); 
            
           canvas.drawText("Test Text", 10, 10, mBlackPaint);
          
       }
      
       /* Callback invoked when the surface dimensions change. */
       public void setSurfaceSize(int width, int height) {
           // synchronized to make sure these all change atomically
           synchronized (mSurfaceHolder) {
               mCanvasWidth = width;
               mCanvasHeight = height;
               Log.i("OverlaySurfaceView "," Canvas Size: " + mCanvasWidth + "x" + mCanvasHeight);
           }
       }

       /**
        * Figures the lander state (x, y, fuel, ...) based on the passage of
        * realtime. Does not invalidate(). Called at the start of draw().
        * Detects the end-of-game and sets the UI to the next state.
        */
       private void updateWorld() {
           long now = System.currentTimeMillis();

           // Do nothing if mLastTime is in the future.
           // This allows the game-start to delay the start of the physics
           // by 100ms or whatever.
           if (mLastTime > now) return;
          
           double elapsed = (now - mLastTime) / 1000.0;

           mLastTime = now;
         
       }
   }

   /** Handle to the application context, used to e.g. fetch Drawables. */
   private Context mContext;

   /** Pointer to the text view to display "Paused.." etc. */
   private TextView mStatusText;

   /** The thread that actually draws the animation */
   private OverlayThread thread;

   public OverlaySurfaceView(Context context) {
       super(context);

       // register our interest in hearing about changes to our surface
       SurfaceHolder holder = getHolder();
       holder.addCallback(this);

       // create thread only; it's started in surfaceCreated()
       thread = new OverlayThread(holder, context);

       setFocusable(true); // make sure we get key events
      
       setBackgroundColor(0x25FF0000);
      
    
   }

   /**
    * Fetches the animation thread corresponding to this LunarView.
    *
    * @return the animation thread
    */
   public OverlayThread getThread() {
       return thread;
   }

 

   /**
    * Standard window-focus override. Notice focus lost so we can pause on
    * focus lost. e.g. user switches to take a call.
    */
   @Override
   public void onWindowFocusChanged(boolean hasWindowFocus) {
       if (!hasWindowFocus) thread.pause();
   }


   /* Callback invoked when the surface dimensions change. */
   public void surfaceChanged(SurfaceHolder holder, int format, int width,
           int height) {
       thread.setSurfaceSize(width, height);
   }

 

   /*
    * Callback invoked when the Surface has been created and is ready to be
    * used.
    */
   public void surfaceCreated(SurfaceHolder holder) {
       // start the thread here so that we don't busy-wait in run()
       // waiting for the surface to be created
       thread.setRunning(true);
       thread.start();
   }

   /*
    * Callback invoked when the Surface has been destroyed and must no longer
    * be touched. WARNING: after this method returns, the Surface/Canvas must
    * never be touched again!
    */
   public void surfaceDestroyed(SurfaceHolder holder) {
       // we have to tell thread to shut down & wait for it to finish, or else
       // it might touch the Surface after we return and explode
       boolean retry = true;
       thread.setRunning(false);
       while (retry) {
           try {
               thread.join();
               retry = false;
           } catch (InterruptedException e) {
           }
       }
   }
  
//    @Override
//    protected void onDraw(Canvas canvas) {
//            // TODO Auto-generated method stub
//
//            Paint paint = new Paint();
//            paint.setStyle(Paint.Style.FILL);
//            paint.setColor(Color.BLACK);
//            canvas.drawText("Test Text", 10, 10, paint);
//
//            super.onDraw(canvas);
//    }
}